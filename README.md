<h1 align="center">Algoritmos de Ordenação</h1>

## Bubble Sort

Um algoritmo bem básico é o ‘Bubble Sort’ ou “Ordenação por Bolha”, a ideia desse algoritmo é comparar pares de elementos adjacentes, ou seja, dois elementos sequências dentro de um array e vai trocar eles de lugar se estiverem na ordem errada, por exemplo, tenho dois elementos um adjacente ao  outro e os mesmos não estão na ordem que eu quero que é crescente ou decrescente, então eu os troco de lugar, tal processo se repete até que mais nenhuma troca seja necessária, ou seja, os (elementos já ordenados), o que torna o elemento bem simples de ordenação. Falando da “Performance”, o melhor caso: O(n), n operações são necessárias para ordenar, ou seja, os dados já estão ordenados então ele só passa uma vez verificando, e seu pior caso: O(n²) então lembrando, o algoritmo básico tem seu desempenho ruim, e uma outra situação é que o mesmo não é recomendado para grandes conjuntos de dados. Portanto o Bubble Sort pode não ser considerado um algoritmo muito eficiente do ponto de vista por performance, ou seja, tudo pelo fato de sua complexidade assintótica muito elevado, uma complexidade de no mínimo O(n²) e tais não são tão eficientes.

## Quick Sort

Algoritmo “QuickSort” ou “Ordenação por troca de Partições”, ou seja, ordenação por troca de partições, onde sua ideia básica é dividir e conquistar. 
Onde iremos dividir esse vetor no qual ao escolher um elemento como pivô e a partir deste fazer o processo de particionar o vetor, onde os dados serão rearranjados de uma forma que os valores menores do que o pivô seja colocados antes do pivô e os maiores depois, com isso tem-se um pivô, e todo número maior que ele de um lado e todos os números menores que ele do outro lado, portanto recursivamente ordenar essas duas partições utilizando o processo de dividir e conquistar.
Sua performance é excelente no melhor caso: O(n log n) e seu pior caso: O(n²), pode-se dizer que é péssimo porém é um caso extremamente raro, ele é um algoritmo estável, ou seja, ele não altera a ordem de dados iguais.
E pode-se dizer que uma desvantagem é: como escolher esse pivô? Pelo fato de existirem várias maneira de escolhê-lo poderá afetar ou não seu desempenho para melhor ou pior do algoritmo.
E onde está o segredo para calcular o pivô? Criar uma função para particionar os dados recebendo um vetor o início e o fim desse mesmo. Onde diz que o pivô é a posição do início do vetor. 
Enquanto a posição da esquerda for menor que direita andasse com a esquerda, ou seja, (aumentado o valor da esquerda) até achar um elemento que não seja menor que o pivô e faz-se o mesmo processo com a direita e enquanto for maior que o pivô vai-se diminuindo e finalizando o processo e se a esquerda é menor que a direita, se sim troca-se os dois de lugar e assim continuasse o processo e quando termina? 
Nesse caso quando a esquerda não for menor que a direita, ou seja, chegará o momento que a direita vai estar menor que a esquerda, portanto é dada uma parada, pois todos foram movimentados e trocados de lugar, portanto o início vai receber o último valor da direita, ou seja, onde a direita parar colocasse no lugar do início e por consequência a posição da direita se torna o valor do pivô e por fim retornasse o valor da direita, ou seja, onde a parada houve com o elemento da direita portanto este é o ponto do vetor onde todos os números antes é menor e todos os números depois é maior, portantos todos os números na sua posição correspondente, ou seja, vetor ordenado. 

## Merge Sort

Algoritmo de ordenação mais sofisticado “MergeSort” ou “Ordenação por Mistura” ou intercalação de elemento, onde sua ideia básica é dividir e conquistar, ou seja é um algoritmo recursivo, onde o mesmo irá dividir recursivamente o conjunto de dados até que cada subconjunto possua um único elemento, por exemplo ao dividir um vetor com oito elementos, de modo que eu tenha oito elementos separados e não como um vetor mais, tudo isso porque? Pelo fato de combinar dois subconjuntos de forma a obter um único conjunto maior e ordenado, ou seja, tem-se um conjunto grande de dados que é difícil de ordenar, portanto dividi-los em conjuntos pequenos  e ordenados pequenos à medida que voltar na recursão combinando esses elementos. E tal processo se repete até que exista apenas um conjunto original ordenado.
Sua performance no melhor caso: O(n log n), uau tem-se um algoritmo be rápido aqui e o pior caso também O(n log n), é um algoritmo estável, ou seja, não tem a ordem de dados que são iguais e sua desvantagem é, que é um algoritmo recursivo tem-se um certo gasto aí pelo fato de fazer a recursão é, o mesmo usa um vetor auxiliar durante toda a ordenação ou seja ele gasta mais memória dos outros algoritmos citados acima até o momento.
O MergeSort é um algoritmo mega inteligente para fazer o processo de ordenação, onde ele vai dividindo o problema onde é mais fácil ordenar dois elementos do que tentar ordenar o vetor inteiro de uma vez e por isso o mesmo é de tão grande desempenho.